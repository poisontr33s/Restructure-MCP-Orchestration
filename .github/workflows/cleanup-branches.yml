name: Cleanup branches

on:
  workflow_dispatch:
    inputs:
      target_branch:
        description: 'Exact remote branch name to delete (e.g., feature/foo). If set, pattern is ignored.'
        required: false
        default: ''
      pattern:
        description: 'Regex to select branches (e.g., ^agent/|^chore/). Ignored when target_branch is set.'
        required: false
        default: ''
      merged_only:
        description: 'Only consider branches already merged into the default branch.'
        required: false
        type: boolean
        default: true
      dry_run:
        description: 'Preview only. When true, shows what would be deleted without pushing deletes.'
        required: false
        type: boolean
        default: true
      exclude_patterns:
        description: 'Comma-separated regex patterns to always keep (e.g., ^main$,^master$,^develop$,^release/).'
        required: false
        default: '^main$,^master$,^develop$,^release/.*,^gh-pages$'

permissions:
  contents: write

concurrency:
  group: cleanup-branches-${{ github.ref }}
  cancel-in-progress: false

jobs:
  cleanup:
    name: Cleanup remote branches
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          persist-credentials: true

      - name: Configure git identity
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

      - name: Determine default branch and fetch
        id: prep
        shell: bash
        run: |
          set -euo pipefail
          DEFAULT_BRANCH="${{ github.event.repository.default_branch }}"
          git remote -v
          git fetch --all --prune
          if [[ -z "${DEFAULT_BRANCH}" ]]; then
            # Fallback from origin/HEAD -> origin/<branch>
            DEFAULT_BRANCH=$(git symbolic-ref --short refs/remotes/origin/HEAD | sed 's#^origin/##')
          fi
          echo "Default branch: ${DEFAULT_BRANCH}"
          echo "default_branch=${DEFAULT_BRANCH}" >> "$GITHUB_OUTPUT"

      - name: Compute candidate branches
        id: compute
        shell: bash
        env:
          TARGET_BRANCH: ${{ inputs.target_branch }}
          PATTERN: ${{ inputs.pattern }}
          MERGED_ONLY: ${{ inputs.merged_only }}
          EXCLUDE_PATTERNS: ${{ inputs.exclude_patterns }}
        run: |
          set -euo pipefail
          DEFAULT_BRANCH='${{ steps.prep.outputs.default_branch }}'

          # Build exclusion regex from comma-separated patterns
          IFS=',' read -r -a EXCLUDE_ARR <<< "${EXCLUDE_PATTERNS}"
          EXCLUDE_REGEX="$(printf '%s|' "${EXCLUDE_ARR[@]}")"
          EXCLUDE_REGEX="${EXCLUDE_REGEX%|}"
          echo "Exclude regex: ${EXCLUDE_REGEX}"

          # Prepare candidate list
          if [[ -n "${TARGET_BRANCH}" ]]; then
            CANDIDATES="${TARGET_BRANCH}"
          else
            if [[ "${MERGED_ONLY}" == "true" ]]; then
              RAW=$(git branch -r --merged "origin/${DEFAULT_BRANCH}" | sed 's/^ *//')
            else
              RAW=$(git branch -r | sed 's/^ *//')
            fi

            # Normalize, drop HEAD pointers, strip origin/ prefix
            CANDIDATES=$(echo "${RAW}" \
              | grep -vE '^origin/HEAD ->' \
              | sed 's#^origin/##' \
              | sort -u)

            # Always exclude the default branch
            CANDIDATES=$(echo "${CANDIDATES}" | grep -vE "^${DEFAULT_BRANCH}$" || true)

            # Apply additional excludes if any
            if [[ -n "${EXCLUDE_REGEX}" ]]; then
              CANDIDATES=$(echo "${CANDIDATES}" | grep -vE "${EXCLUDE_REGEX}" || true)
            fi

            # Apply user-supplied pattern if provided
            if [[ -n "${PATTERN}" ]]; then
              CANDIDATES=$(echo "${CANDIDATES}" | grep -E "${PATTERN}" || true)
            fi
          fi

          # Materialize list and count
          echo "Candidates (pre-filtered):"
          echo "${CANDIDATES}" | sed '/^$/d' | nl -ba || true
          COUNT=$(echo "${CANDIDATES}" | sed '/^$/d' | wc -l | tr -d ' ')
          echo "count=${COUNT}" >> "$GITHUB_OUTPUT"
          # Save to file for the next step
          echo "${CANDIDATES}" | sed '/^$/d' > branches.txt

      - name: Show plan (dry-run preview)
        if: inputs.dry_run == true
        run: |
          echo "Dry run enabled. The following ${{ steps.compute.outputs.count }} branch(es) would be deleted:"
          cat branches.txt || true

      - name: Delete branches
        if: inputs.dry_run == false
        shell: bash
        run: |
          set -euo pipefail
          if [[ ! -s branches.txt ]]; then
            echo "No branches to delete."
            exit 0
          fi
          while IFS= read -r BR; do
            if [[ -z "${BR}" ]]; then continue; fi
            echo "Deleting remote branch: ${BR}"
            if git push origin --delete "${BR}"; then
              echo "Deleted ${BR}"
            else
              echo "Failed to delete ${BR} (may be protected or already gone)" >&2
            fi
+          done < branches.txt
